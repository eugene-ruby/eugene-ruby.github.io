---
layout: post
title: "Рефайнменты - refine"
date:  2023-07-23 14:52:48 +0300
categories: refine
toc: true
menubar_toc: true
hero_image: /images/rubu-back.jpeg
hero_darken: true
---

<img alt="ded" src="/images/refinements.jpeg" width="40%"/>
# Рефайнменты `refine` в Ruby


## В двух словах об refinements

Конструкция `refine` в Ruby используется для определения изменений или улучшений, называемых "рефайнментами" (refinements), 
которые могут быть применены к классам или модулям. 
Рефайнменты позволяют изменять поведение существующих классов или модулей в ограниченной области видимости.

```ruby
module KernelRefinement
  refine Kernel do
    def some_method
      # some code
    end
  end
end
```

В примере, `refine Kernel` указывает, что вы хотите применить рефайнменты к классу `Kernel`. 
Затем вы определяете блок кода, в котором вы можете внести изменения в класс `Kernel`. 
Внутри этого блока вы можете добавлять новые методы.

Применение рефайнментов осуществляется с помощью ключевого слова `using`.
Например, если вы хотите использовать рефайнменты из модуля `KernelRefinement`, вы можете сделать следующее:

```ruby
using KernelRefinement

# Ваш код, в котором будут применены рефайнменты
```

## Примеры

### Пример 1

Использование `refine` для добавления метода к классу:

```ruby
module MyRefinement
  refine String do
    def reverse_upcase
      self.reverse.upcase
    end
  end
end

using MyRefinement

puts "hello".reverse_upcase # Выводит "OLLEH"
```

### Пример 2

Использование `refine` для изменения поведения метода в классе:

```ruby
module MyRefinement
  refine String do
    def upcase
      "This is a secret!"
    end
  end
end

using MyRefinement

puts "hello".upcase # Выводит "This is a secret!"
puts "world".upcase # Выводит "This is a secret!"
```

### Пример 3
Использование `refine` для добавления метода экземпляра к модулю:

```ruby
module MyModule
  refine Integer do
    def square
      self * self
    end
  end
end

class MyClass
  using MyModule

  def initialize(value)
    @value = value
  end

  def squared_value
    @value.square
  end
end

puts MyClass.new(5).squared_value # Выводит 25
```

### Пример 3 (RSpec-теста)
Пример RSpec-теста для класса `MyClass` с использованием `refine`

```ruby
require 'rspec'

RSpec.describe MyClass do
  using MyModule

  describe '#squared_value' do
    it 'returns the squared value' do
      my_object = MyClass.new(5)
      expect(my_object.squared_value).to eq(25)
    end
  end
end
```

В RSpec, вызов `using MyModule` внутри блока `RSpec.describe` гарантирует, что рефайнменты, определенные в модуле `MyModule`, будут применяться внутри тестового контекста.

Поскольку рефайнменты применяются только в контексте, где был вызван `using`, это необходимо для того, чтобы убедиться, что рефайнменты будут действовать внутри тестовых методов, таких как `describe` и `it`.

Таким образом, вызов `using MyModule` внутри блока `RSpec.describe` гарантирует, что рефайнменты будут применяться при вызове метода `squared_value` внутри тестового метода `it`.


В этих примерах `refine` используется для временного изменения поведения классов или модулей в ограниченной области с помощью ключевого слова `using`.

Когда рефайнменты применены с помощью `using`, они будут действовать только внутри области видимости, где был вызван `using`. Это позволяет вам контролировать, где и когда применяются изменения, определенные в рефайнментах.

Обратите внимание, что рефайнменты не изменяют классы или модули непосредственно. Они применяются только в контексте, где был вызван `using`. Это позволяет избежать неожиданных изменений в других частях кода, которые могут использовать тот же класс или модуль.

## refine vs include

Использование `refine` вместо `include` модуля имеет несколько преимуществ:

1. Локальность: `refine` применяется только внутри блока, где он объявлен. Это означает, что изменения, внесенные с помощью `refine`, не затрагивают другие части кода, которые могут использовать тот же класс или модуль. Это позволяет избежать конфликтов имен и неожиданных побочных эффектов.

2. Контролируемый доступ: `refine` позволяет контролировать, где именно применяются изменения. Вы можете явно указать, где и когда использовать рефайнменты, вместо того чтобы включать модуль весь класс или объект.

3. Читаемость кода: Использование `refine` может сделать код более читаемым и понятным. Поскольку изменения, внесенные с помощью `refine`, ограничены только на определенный блок кода, это может помочь сосредоточиться на конкретной функциональности или логике.

Однако следует отметить, что `refine` имеет некоторые ограничения и особенности, которые могут быть не всегда подходят для всех ситуаций. Например, `refine` не работает с методами, определенными в самом классе, и не может быть использован внутри методов. Также, `refine` не может быть использован в глобальной области видимости.

В целом, использование `refine` или `include` зависит от конкретной ситуации и предпочтений разработчика.

## Ограничения 

При использовании `refine`, вы не можете изменять или переопределять методы, которые уже определены в самом классе или модуле, к которому применяется рефайнмент.

Например, предположим, у вас есть класс `MyClass` с определенным методом `my_method`:

```ruby
class MyClass
  def my_method
    puts "Original method"
  end
end
```

Если вы попытаетесь использовать `refine` для изменения метода `my_method`, это не будет работать:

```ruby
module MyRefinement
  refine MyClass do
    def my_method
      puts "Refined method"
    end
  end
end

using MyRefinement

obj = MyClass.new
obj.my_method # Выведет "Original method", а не "Refined method"
```

В этом случае, метод `my_method` в классе `MyClass` не будет затронут рефайнментом, и будет продолжать работать как обычно.

Однако, вы можете использовать `refine` для добавления новых методов или изменения методов, которые уже определены в других модулях или классах, но не в самом классе или модуле, к которому применяется рефайнмент.
